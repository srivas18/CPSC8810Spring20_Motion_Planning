Assignment 4 : Sampling Based Navigation
CPSC 8810 - Motion Planning
ASSIGNMENT 3: Discrete Planning
Submitted by: Aakanksha Smriti, Siddhant Srivastava
Submission date: 03-10-2020

1) Construction Phase : For the construction phase, we first created a function 'perturb()' to generate a mesh grid of x and y samples and to add a noise to those samples for randomness. Next, the vertices were added inside the obstacle free configuration space considering the robot radius. After adding all the points inside the C Space, edges are added between the vertices that are within a certain distance from a certain vertex. To avoid vertices from connecting through obstacles to form edges, an "interpolate()" function was created to check the local path between two given configurations. It was used to determine whether an edge between vertices is collision-free. After making these checks, another check is performed to connect configurations if they are not previously connected by using the connectedComponentNr variable. If it is -1 then the vertices aren't connected. If the vertices are already connected, then a separate function called "find()" was created to check for common parents between two parents. In order to achieve this, first the previous parents are stored in the list 'paths[]' with the help of connectedComponentNr and then the vertices of every edge from the set of parents are computed and returned as a list called 'roads[]'.
Note: After clicking generate Roadmap it sometimes takes a lot of time to generate the roadmap. This is because of the noise that has been added to the random samples. If the noise is removed completely for meshgrid, the roadmap gets generated immediately as soon as you click on the button. We have included a screenshot of the successful simulation from start to goal node for reference.

2) Query Phase: For query phase, the A* search algorithm is used to compute the path from the start to the goal node. This was done through "find_path()" function which takes in start node, goal node and the graph as arguments. This function has already been passed inside the Scene class defined inside scene.py. "start" and "goal" are variables to add the start and goal vertex inside the obstacle-free C-space. To add the edge from the start to its nearby vertices, the same process during the construction phase was repeated to add edges. Parent variable which is an empty tuple is declared which has the length of (graph.getNrVertices(),2). A heuristic list was computed that calculates the distance from the goal vertex to all the vertices. Next, we found the index where heuristic value is equal to start and goal node distance, this is used as the starting point of the path (start_node). We first inserted the start node into the open set. After following these steps, the A* algorithm is run by popping the start node from the open set and adding to the closed set. The path to take from the start node to the next node is computed on the basis of heuristic and g_value (which is the euclidean distance from the neighboring node to the current node). If the neighboring node is not in closed set and not in open set, then the neighboring node is pushed based on the f-value. To trace back the path from the goal to start we ran a while loop untill we reached the start node and at every iteration we kept on updating the previous node as current node so that we can trace back the path. We used 'path.reverse()' to correct the colors of the path traced. If during random query, any of the start or goal nodes lie in the obstacle space and you try to generate a path, the code enters into an infinite loop and does not return anything which means it is unable to find a path to the goal node. 

 